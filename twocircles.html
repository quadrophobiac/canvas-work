<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Two Circles in Orbit</title>
    <style>
        body{
            margin: 0px;
            padding: 0px;
        }
        canvas { position: absolute; }

        #BaseCanvas {
            z-index: 1;
            top: 0;
            border: 1px #CCC solid;
            background-color: rgba(158, 167, 184, 0.2);
        }

        #CircleCanvas {
            z-index: 2;
            top: 0;
            border: 1px #CCC solid;
            background-color: rgba(204, 45, 42, 0.20);
        }

        #staticCircle{
            color: rgb(0,153,255);
        }

        #movingOmmission{
            color: rgb(49, 255, 80);
        }

        table {
            position: absolute;
            bottom: 10%;
            height: 0;
            line-height: 0;
            padding-top: 0;
            padding-bottom: 10px;
            margin-left: 3px;
            margin-right: 3px;
            color: #180506;
            /*border: none;*/
            white-space: nowrap;
        }

    </style>

</head>
<body>
<h1 id="frame_count"></h1>

<div id="container">
    <canvas id="CircleCanvas" width="900" height="300">

    </canvas>
    <canvas id="BaseCanvas" width="900" height="300">

    </canvas>
    <!--<span><p id="rotation"></p><p id="rotat">Tet</p></span>-->
    <table>
        <tr style="white-space: nowrap;">
            <td>circle 1: </td>
            <td id="circle1"></td>
            <td>circle 2: </td>
            <td id="circle2"></td>
            <td>circle 3: </td>
            <td id="circle3"></td>
        </tr>
    </table>
</div>

<script>


    // variables for tracking the time elapsed between orbits
    var now;
    var then = Date.now();
    var delta;
    var frameCounter = 0;
    var frameInterval = 60;
    var first = then;


    var baseCanvas = document.getElementById("BaseCanvas");
    var baseContext = baseCanvas.getContext('2d');

    var mainCanvas = document.getElementById("CircleCanvas");
    var mainContext = mainCanvas.getContext('2d');


    var orbits = new Array();
    var $ = document.querySelector.bind(document);

    var requestAnimationFrame = window.requestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.msRequestAnimationFrame;
    // above must be fallbacks dependant on which browser will be used

    function orbit() {

    }

    function Circle(xPos, startAngle, endAngle, color, speed, name, stroke){
        this.yPos = 150; // hardcoded because of canvas size
        this.width = 105; // hardcoded param
        this.counter = 0; // counter is an internal value that we can use to modulate other params
        this.startAngle = startAngle+0.05;
        this.endAngle = endAngle-0.05;
        this.xPos = xPos;
        this.color = color || 'lightgreen';
        this.speed = speed || 0.05;
        this.name = name;
        this.stroke = stroke || 5;
    }

    Circle.prototype.draw = function(){
        // abstracting the canvas rendering methods into this function
        // can either pass speed as a param for this function, or include it as a property of each circle
        this.counter += this.speed;
        mainContext.lineWidth = this.stroke;
        mainContext.strokeStyle = this.color;
        mainContext.beginPath();
        mainContext.arc(
                this.xPos,
                this.yPos,
                this.width,
                this.startAngle+this.counter,
                this.endAngle+this.counter,// end angle
                false
        );
//        mainContext.rotate(90);
        mainContext.stroke();
        mainContext.closePath();
//        console.log($('#'+this.name)); // evaluates fine
        $('#'+this.name).innerHTML =
                this.counter.toPrecision(3) + ' rf ';
//        console.log("circle"+this.name+" passed");
    }

    function circleTest(){
        // will render a simple circle fitting the canvas with a chunk of its stroke missing
        baseContext.clearRect(0,0,900,300);
        baseContext.lineWidth = 2;
        baseContext.strokeStyle = 'rgba(204, 45, 42, 0.20)';
        baseContext.arc(
                400,
                150,
                105,
                Math.PI*0.00,// start angle = 3.141592653589793
                Math.PI*1.999999,// end angle  = 6.283185307179586
                false
        );

        baseContext.stroke();
        baseContext.closePath();

    }
    circleTest();
    createCircles();

//    draw();


    function createCircles(){
        // 6.28 = makes the circle move anti clockwise
        var orbit1 = new Circle(150,Math.PI*1.5,Math.PI*1.5, 'rgb(49, 255, 80)', 0.05, 'circle1'); // 12 o clock start
        // Math.Pi * 1.99^^^ / 60 = 0.104666667 == 1 second loop
        var orbit2 = new Circle(400, Math.PI*1.45,Math.PI*1.5, 'rgb(0,153,255)',0.104666667, 'circle2');
        var orbit3 = new Circle(650, 0,Math.PI*1.999999999, 'rgb(0,153,255)',0.000000000001, 'circle3', 2);
        orbits.push(orbit1, orbit2, orbit3);
        console.log(orbits.length);
        console.log("Pi * 0.5= "+Math.PI*0.5+" Pi*1 = "+Math.PI*1.0+"+Math.PI*1.5 = "+Math.PI*1.4+" Math.PI*2.0 = "+Math.PI*2);
        draw();
    }

    function draw(){

        // function that calls itself, triggering animation
        mainContext.clearRect(0,0,900,300);

        // time tracker logic
        now = Date.now();
        delta = now - then;
        if (delta > frameInterval) {
            // update time stuffs
            then = now - (delta % frameInterval);
            // ... Code for Drawing the Frame ...
            var time_el = (then - first) / 1000;
            // update a table that displays one circle per cell
            $('#frame_count').innerHTML =
                    ++frameCounter + 'f / ' + parseInt(time_el) + 's = ';
        }
        // draw the circular orbits
        for(i = 0; i < orbits.length; i++){
            var theOrbit = orbits[i];
            // console.log(theOrbit);
            theOrbit.draw();
        }
        requestAnimationFrame(draw);
        // accurate to the thousandth of millisecond
    }

    /* I want to draw an arc that creates the line outline of a circle
    * convention for this is that the params for arc:
    * start angle = 0
    * end angle = Math.PI*2 : however 360 also works
    * , to achieve effect of chunk missing from arc, you can do Math.PI*2
    * initial param can also be wrttien Math.PI*0,Math.PI*1.95
    * */


    /*
     2*Math.PI)/60000 ~

     12 o clock = PI*1.5 = 4.39822971502571
     3 o clock = Math.PI*2.0 = 6.283185307179586 || Math.PI
     6 o clock = Pi * 0.5 = 1.5707963267948966
     9 o clock Pi*1 = 3.141592653589793+Math.
    *
    * */

    /* Possible refresh rates
   50 hz = upper limit of visually discernable
   0.0 - Math.PI*1.99 = range which completes a circle
   Math.PI*1.99 = 6.28^^^^ - Pi can extend to however many decimal places desired
    */
</script>

</body>
</html>